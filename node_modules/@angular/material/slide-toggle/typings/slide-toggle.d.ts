/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { FocusMonitor } from '@angular/cdk/a11y';
import { Directionality } from '@angular/cdk/bidi';
import { AfterContentInit, ChangeDetectorRef, ElementRef, EventEmitter, OnDestroy, NgZone } from '@angular/core';
import { ControlValueAccessor } from '@angular/forms';
import { CanColor, CanColorCtor, CanDisable, CanDisableCtor, CanDisableRipple, CanDisableRippleCtor, HammerInput, HasTabIndex, HasTabIndexCtor } from '@angular/material/core';
import { MatSlideToggleDefaultOptions } from './slide-toggle-config';
/** @docs-private */
import * as ɵngcc0 from '@angular/core';
export declare const MAT_SLIDE_TOGGLE_VALUE_ACCESSOR: any;
/** Change event object emitted by a MatSlideToggle. */
export declare class MatSlideToggleChange {
    /** The source MatSlideToggle of the event. */
    source: MatSlideToggle;
    /** The new `checked` value of the MatSlideToggle. */
    checked: boolean;
    constructor(
    /** The source MatSlideToggle of the event. */
    source: MatSlideToggle, 
    /** The new `checked` value of the MatSlideToggle. */
    checked: boolean);
}
/** @docs-private */
declare class MatSlideToggleBase {
    _elementRef: ElementRef;
    constructor(_elementRef: ElementRef);
}
declare const _MatSlideToggleMixinBase: HasTabIndexCtor & CanColorCtor & CanDisableRippleCtor & CanDisableCtor & typeof MatSlideToggleBase;
/** Represents a slidable "switch" toggle that can be moved between on and off. */
export declare class MatSlideToggle extends _MatSlideToggleMixinBase implements OnDestroy, AfterContentInit, ControlValueAccessor, CanDisable, CanColor, HasTabIndex, CanDisableRipple {
    private _focusMonitor;
    private _changeDetectorRef;
    private _ngZone;
    defaults: MatSlideToggleDefaultOptions;
    _animationMode?: string | undefined;
    private _dir?;
    private _onChange;
    private _onTouched;
    private _uniqueId;
    private _required;
    private _checked;
    /** Whether the thumb is currently being dragged. */
    private _dragging;
    /** Previous checked state before drag started. */
    private _previousChecked;
    /** Width of the thumb bar of the slide-toggle. */
    private _thumbBarWidth;
    /** Percentage of the thumb while dragging. Percentage as fraction of 100. */
    private _dragPercentage;
    /** Reference to the thumb HTMLElement. */
    _thumbEl: ElementRef;
    /** Reference to the thumb bar HTMLElement. */
    _thumbBarEl: ElementRef;
    /** Name value will be applied to the input element if present. */
    name: string | null;
    /** A unique id for the slide-toggle input. If none is supplied, it will be auto-generated. */
    id: string;
    /** Whether the label should appear after or before the slide-toggle. Defaults to 'after'. */
    labelPosition: 'before' | 'after';
    /** Used to set the aria-label attribute on the underlying input element. */
    ariaLabel: string | null;
    /** Used to set the aria-labelledby attribute on the underlying input element. */
    ariaLabelledby: string | null;
    /** Whether the slide-toggle is required. */
    required: boolean;
    /** Whether the slide-toggle element is checked or not. */
    checked: boolean;
    /** An event will be dispatched each time the slide-toggle changes its value. */
    readonly change: EventEmitter<MatSlideToggleChange>;
    /**
     * An event will be dispatched each time the slide-toggle input is toggled.
     * This event is always emitted when the user toggles the slide toggle, but this does not mean
     * the slide toggle's value has changed. The event does not fire when the user drags to change
     * the slide toggle value.
     */
    readonly toggleChange: EventEmitter<void>;
    /**
     * An event will be dispatched each time the slide-toggle is dragged.
     * This event is always emitted when the user drags the slide toggle to make a change greater
     * than 50%. It does not mean the slide toggle's value is changed. The event is not emitted when
     * the user toggles the slide toggle to change its value.
     */
    readonly dragChange: EventEmitter<void>;
    /** Returns the unique id for the visual hidden input. */
    readonly inputId: string;
    /** Reference to the underlying input element. */
    _inputElement: ElementRef<HTMLInputElement>;
    constructor(elementRef: ElementRef, _focusMonitor: FocusMonitor, _changeDetectorRef: ChangeDetectorRef, tabIndex: string, _ngZone: NgZone, defaults: MatSlideToggleDefaultOptions, _animationMode?: string | undefined, _dir?: Directionality | undefined);
    ngAfterContentInit(): void;
    ngOnDestroy(): void;
    /** Method being called whenever the underlying input emits a change event. */
    _onChangeEvent(event: Event): void;
    /** Method being called whenever the slide-toggle has been clicked. */
    _onInputClick(event: Event): void;
    /** Implemented as part of ControlValueAccessor. */
    writeValue(value: any): void;
    /** Implemented as part of ControlValueAccessor. */
    registerOnChange(fn: any): void;
    /** Implemented as part of ControlValueAccessor. */
    registerOnTouched(fn: any): void;
    /** Implemented as a part of ControlValueAccessor. */
    setDisabledState(isDisabled: boolean): void;
    /** Focuses the slide-toggle. */
    focus(options?: FocusOptions): void;
    /** Toggles the checked state of the slide-toggle. */
    toggle(): void;
    /**
     * Emits a change event on the `change` output. Also notifies the FormControl about the change.
     */
    private _emitChangeEvent;
    /** Retrieves the percentage of thumb from the moved distance. Percentage as fraction of 100. */
    private _getDragPercentage;
    _onDragStart(): void;
    _onDrag(event: HammerInput): void;
    _onDragEnd(): void;
    /** Method being called whenever the label text changes. */
    _onLabelTextChange(): void;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<MatSlideToggle, [null, null, null, { attribute: "tabindex"; }, null, null, { optional: true; }, { optional: true; }]>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<MatSlideToggle, "mat-slide-toggle", ["matSlideToggle"], { "disabled": "disabled"; "disableRipple": "disableRipple"; "color": "color"; "tabIndex": "tabIndex"; "name": "name"; "id": "id"; "labelPosition": "labelPosition"; "ariaLabel": "aria-label"; "ariaLabelledby": "aria-labelledby"; "required": "required"; "checked": "checked"; }, { "change": "change"; "toggleChange": "toggleChange"; "dragChange": "dragChange"; }, never, ["*"]>;
}
export {};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2xpZGUtdG9nZ2xlLmQudHMiLCJzb3VyY2VzIjpbInNsaWRlLXRvZ2dsZS5kLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7QUFjQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE0R0EiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuICpcclxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcclxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHsgRm9jdXNNb25pdG9yIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2ExMXknO1xyXG5pbXBvcnQgeyBEaXJlY3Rpb25hbGl0eSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9iaWRpJztcclxuaW1wb3J0IHsgQWZ0ZXJDb250ZW50SW5pdCwgQ2hhbmdlRGV0ZWN0b3JSZWYsIEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgT25EZXN0cm95LCBOZ1pvbmUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgQ29udHJvbFZhbHVlQWNjZXNzb3IgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XHJcbmltcG9ydCB7IENhbkNvbG9yLCBDYW5Db2xvckN0b3IsIENhbkRpc2FibGUsIENhbkRpc2FibGVDdG9yLCBDYW5EaXNhYmxlUmlwcGxlLCBDYW5EaXNhYmxlUmlwcGxlQ3RvciwgSGFtbWVySW5wdXQsIEhhc1RhYkluZGV4LCBIYXNUYWJJbmRleEN0b3IgfSBmcm9tICdAYW5ndWxhci9tYXRlcmlhbC9jb3JlJztcclxuaW1wb3J0IHsgTWF0U2xpZGVUb2dnbGVEZWZhdWx0T3B0aW9ucyB9IGZyb20gJy4vc2xpZGUtdG9nZ2xlLWNvbmZpZyc7XHJcbi8qKiBAZG9jcy1wcml2YXRlICovXHJcbmV4cG9ydCBkZWNsYXJlIGNvbnN0IE1BVF9TTElERV9UT0dHTEVfVkFMVUVfQUNDRVNTT1I6IGFueTtcclxuLyoqIENoYW5nZSBldmVudCBvYmplY3QgZW1pdHRlZCBieSBhIE1hdFNsaWRlVG9nZ2xlLiAqL1xyXG5leHBvcnQgZGVjbGFyZSBjbGFzcyBNYXRTbGlkZVRvZ2dsZUNoYW5nZSB7XHJcbiAgICAvKiogVGhlIHNvdXJjZSBNYXRTbGlkZVRvZ2dsZSBvZiB0aGUgZXZlbnQuICovXHJcbiAgICBzb3VyY2U6IE1hdFNsaWRlVG9nZ2xlO1xyXG4gICAgLyoqIFRoZSBuZXcgYGNoZWNrZWRgIHZhbHVlIG9mIHRoZSBNYXRTbGlkZVRvZ2dsZS4gKi9cclxuICAgIGNoZWNrZWQ6IGJvb2xlYW47XHJcbiAgICBjb25zdHJ1Y3RvcihcclxuICAgIC8qKiBUaGUgc291cmNlIE1hdFNsaWRlVG9nZ2xlIG9mIHRoZSBldmVudC4gKi9cclxuICAgIHNvdXJjZTogTWF0U2xpZGVUb2dnbGUsIFxyXG4gICAgLyoqIFRoZSBuZXcgYGNoZWNrZWRgIHZhbHVlIG9mIHRoZSBNYXRTbGlkZVRvZ2dsZS4gKi9cclxuICAgIGNoZWNrZWQ6IGJvb2xlYW4pO1xyXG59XHJcbi8qKiBAZG9jcy1wcml2YXRlICovXHJcbmRlY2xhcmUgY2xhc3MgTWF0U2xpZGVUb2dnbGVCYXNlIHtcclxuICAgIF9lbGVtZW50UmVmOiBFbGVtZW50UmVmO1xyXG4gICAgY29uc3RydWN0b3IoX2VsZW1lbnRSZWY6IEVsZW1lbnRSZWYpO1xyXG59XHJcbmRlY2xhcmUgY29uc3QgX01hdFNsaWRlVG9nZ2xlTWl4aW5CYXNlOiBIYXNUYWJJbmRleEN0b3IgJiBDYW5Db2xvckN0b3IgJiBDYW5EaXNhYmxlUmlwcGxlQ3RvciAmIENhbkRpc2FibGVDdG9yICYgdHlwZW9mIE1hdFNsaWRlVG9nZ2xlQmFzZTtcclxuLyoqIFJlcHJlc2VudHMgYSBzbGlkYWJsZSBcInN3aXRjaFwiIHRvZ2dsZSB0aGF0IGNhbiBiZSBtb3ZlZCBiZXR3ZWVuIG9uIGFuZCBvZmYuICovXHJcbmV4cG9ydCBkZWNsYXJlIGNsYXNzIE1hdFNsaWRlVG9nZ2xlIGV4dGVuZHMgX01hdFNsaWRlVG9nZ2xlTWl4aW5CYXNlIGltcGxlbWVudHMgT25EZXN0cm95LCBBZnRlckNvbnRlbnRJbml0LCBDb250cm9sVmFsdWVBY2Nlc3NvciwgQ2FuRGlzYWJsZSwgQ2FuQ29sb3IsIEhhc1RhYkluZGV4LCBDYW5EaXNhYmxlUmlwcGxlIHtcclxuICAgIHByaXZhdGUgX2ZvY3VzTW9uaXRvcjtcclxuICAgIHByaXZhdGUgX2NoYW5nZURldGVjdG9yUmVmO1xyXG4gICAgcHJpdmF0ZSBfbmdab25lO1xyXG4gICAgZGVmYXVsdHM6IE1hdFNsaWRlVG9nZ2xlRGVmYXVsdE9wdGlvbnM7XHJcbiAgICBfYW5pbWF0aW9uTW9kZT86IHN0cmluZyB8IHVuZGVmaW5lZDtcclxuICAgIHByaXZhdGUgX2Rpcj87XHJcbiAgICBwcml2YXRlIF9vbkNoYW5nZTtcclxuICAgIHByaXZhdGUgX29uVG91Y2hlZDtcclxuICAgIHByaXZhdGUgX3VuaXF1ZUlkO1xyXG4gICAgcHJpdmF0ZSBfcmVxdWlyZWQ7XHJcbiAgICBwcml2YXRlIF9jaGVja2VkO1xyXG4gICAgLyoqIFdoZXRoZXIgdGhlIHRodW1iIGlzIGN1cnJlbnRseSBiZWluZyBkcmFnZ2VkLiAqL1xyXG4gICAgcHJpdmF0ZSBfZHJhZ2dpbmc7XHJcbiAgICAvKiogUHJldmlvdXMgY2hlY2tlZCBzdGF0ZSBiZWZvcmUgZHJhZyBzdGFydGVkLiAqL1xyXG4gICAgcHJpdmF0ZSBfcHJldmlvdXNDaGVja2VkO1xyXG4gICAgLyoqIFdpZHRoIG9mIHRoZSB0aHVtYiBiYXIgb2YgdGhlIHNsaWRlLXRvZ2dsZS4gKi9cclxuICAgIHByaXZhdGUgX3RodW1iQmFyV2lkdGg7XHJcbiAgICAvKiogUGVyY2VudGFnZSBvZiB0aGUgdGh1bWIgd2hpbGUgZHJhZ2dpbmcuIFBlcmNlbnRhZ2UgYXMgZnJhY3Rpb24gb2YgMTAwLiAqL1xyXG4gICAgcHJpdmF0ZSBfZHJhZ1BlcmNlbnRhZ2U7XHJcbiAgICAvKiogUmVmZXJlbmNlIHRvIHRoZSB0aHVtYiBIVE1MRWxlbWVudC4gKi9cclxuICAgIF90aHVtYkVsOiBFbGVtZW50UmVmO1xyXG4gICAgLyoqIFJlZmVyZW5jZSB0byB0aGUgdGh1bWIgYmFyIEhUTUxFbGVtZW50LiAqL1xyXG4gICAgX3RodW1iQmFyRWw6IEVsZW1lbnRSZWY7XHJcbiAgICAvKiogTmFtZSB2YWx1ZSB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIGlucHV0IGVsZW1lbnQgaWYgcHJlc2VudC4gKi9cclxuICAgIG5hbWU6IHN0cmluZyB8IG51bGw7XHJcbiAgICAvKiogQSB1bmlxdWUgaWQgZm9yIHRoZSBzbGlkZS10b2dnbGUgaW5wdXQuIElmIG5vbmUgaXMgc3VwcGxpZWQsIGl0IHdpbGwgYmUgYXV0by1nZW5lcmF0ZWQuICovXHJcbiAgICBpZDogc3RyaW5nO1xyXG4gICAgLyoqIFdoZXRoZXIgdGhlIGxhYmVsIHNob3VsZCBhcHBlYXIgYWZ0ZXIgb3IgYmVmb3JlIHRoZSBzbGlkZS10b2dnbGUuIERlZmF1bHRzIHRvICdhZnRlcicuICovXHJcbiAgICBsYWJlbFBvc2l0aW9uOiAnYmVmb3JlJyB8ICdhZnRlcic7XHJcbiAgICAvKiogVXNlZCB0byBzZXQgdGhlIGFyaWEtbGFiZWwgYXR0cmlidXRlIG9uIHRoZSB1bmRlcmx5aW5nIGlucHV0IGVsZW1lbnQuICovXHJcbiAgICBhcmlhTGFiZWw6IHN0cmluZyB8IG51bGw7XHJcbiAgICAvKiogVXNlZCB0byBzZXQgdGhlIGFyaWEtbGFiZWxsZWRieSBhdHRyaWJ1dGUgb24gdGhlIHVuZGVybHlpbmcgaW5wdXQgZWxlbWVudC4gKi9cclxuICAgIGFyaWFMYWJlbGxlZGJ5OiBzdHJpbmcgfCBudWxsO1xyXG4gICAgLyoqIFdoZXRoZXIgdGhlIHNsaWRlLXRvZ2dsZSBpcyByZXF1aXJlZC4gKi9cclxuICAgIHJlcXVpcmVkOiBib29sZWFuO1xyXG4gICAgLyoqIFdoZXRoZXIgdGhlIHNsaWRlLXRvZ2dsZSBlbGVtZW50IGlzIGNoZWNrZWQgb3Igbm90LiAqL1xyXG4gICAgY2hlY2tlZDogYm9vbGVhbjtcclxuICAgIC8qKiBBbiBldmVudCB3aWxsIGJlIGRpc3BhdGNoZWQgZWFjaCB0aW1lIHRoZSBzbGlkZS10b2dnbGUgY2hhbmdlcyBpdHMgdmFsdWUuICovXHJcbiAgICByZWFkb25seSBjaGFuZ2U6IEV2ZW50RW1pdHRlcjxNYXRTbGlkZVRvZ2dsZUNoYW5nZT47XHJcbiAgICAvKipcclxuICAgICAqIEFuIGV2ZW50IHdpbGwgYmUgZGlzcGF0Y2hlZCBlYWNoIHRpbWUgdGhlIHNsaWRlLXRvZ2dsZSBpbnB1dCBpcyB0b2dnbGVkLlxyXG4gICAgICogVGhpcyBldmVudCBpcyBhbHdheXMgZW1pdHRlZCB3aGVuIHRoZSB1c2VyIHRvZ2dsZXMgdGhlIHNsaWRlIHRvZ2dsZSwgYnV0IHRoaXMgZG9lcyBub3QgbWVhblxyXG4gICAgICogdGhlIHNsaWRlIHRvZ2dsZSdzIHZhbHVlIGhhcyBjaGFuZ2VkLiBUaGUgZXZlbnQgZG9lcyBub3QgZmlyZSB3aGVuIHRoZSB1c2VyIGRyYWdzIHRvIGNoYW5nZVxyXG4gICAgICogdGhlIHNsaWRlIHRvZ2dsZSB2YWx1ZS5cclxuICAgICAqL1xyXG4gICAgcmVhZG9ubHkgdG9nZ2xlQ2hhbmdlOiBFdmVudEVtaXR0ZXI8dm9pZD47XHJcbiAgICAvKipcclxuICAgICAqIEFuIGV2ZW50IHdpbGwgYmUgZGlzcGF0Y2hlZCBlYWNoIHRpbWUgdGhlIHNsaWRlLXRvZ2dsZSBpcyBkcmFnZ2VkLlxyXG4gICAgICogVGhpcyBldmVudCBpcyBhbHdheXMgZW1pdHRlZCB3aGVuIHRoZSB1c2VyIGRyYWdzIHRoZSBzbGlkZSB0b2dnbGUgdG8gbWFrZSBhIGNoYW5nZSBncmVhdGVyXHJcbiAgICAgKiB0aGFuIDUwJS4gSXQgZG9lcyBub3QgbWVhbiB0aGUgc2xpZGUgdG9nZ2xlJ3MgdmFsdWUgaXMgY2hhbmdlZC4gVGhlIGV2ZW50IGlzIG5vdCBlbWl0dGVkIHdoZW5cclxuICAgICAqIHRoZSB1c2VyIHRvZ2dsZXMgdGhlIHNsaWRlIHRvZ2dsZSB0byBjaGFuZ2UgaXRzIHZhbHVlLlxyXG4gICAgICovXHJcbiAgICByZWFkb25seSBkcmFnQ2hhbmdlOiBFdmVudEVtaXR0ZXI8dm9pZD47XHJcbiAgICAvKiogUmV0dXJucyB0aGUgdW5pcXVlIGlkIGZvciB0aGUgdmlzdWFsIGhpZGRlbiBpbnB1dC4gKi9cclxuICAgIHJlYWRvbmx5IGlucHV0SWQ6IHN0cmluZztcclxuICAgIC8qKiBSZWZlcmVuY2UgdG8gdGhlIHVuZGVybHlpbmcgaW5wdXQgZWxlbWVudC4gKi9cclxuICAgIF9pbnB1dEVsZW1lbnQ6IEVsZW1lbnRSZWY8SFRNTElucHV0RWxlbWVudD47XHJcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50UmVmOiBFbGVtZW50UmVmLCBfZm9jdXNNb25pdG9yOiBGb2N1c01vbml0b3IsIF9jaGFuZ2VEZXRlY3RvclJlZjogQ2hhbmdlRGV0ZWN0b3JSZWYsIHRhYkluZGV4OiBzdHJpbmcsIF9uZ1pvbmU6IE5nWm9uZSwgZGVmYXVsdHM6IE1hdFNsaWRlVG9nZ2xlRGVmYXVsdE9wdGlvbnMsIF9hbmltYXRpb25Nb2RlPzogc3RyaW5nIHwgdW5kZWZpbmVkLCBfZGlyPzogRGlyZWN0aW9uYWxpdHkgfCB1bmRlZmluZWQpO1xyXG4gICAgbmdBZnRlckNvbnRlbnRJbml0KCk6IHZvaWQ7XHJcbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkO1xyXG4gICAgLyoqIE1ldGhvZCBiZWluZyBjYWxsZWQgd2hlbmV2ZXIgdGhlIHVuZGVybHlpbmcgaW5wdXQgZW1pdHMgYSBjaGFuZ2UgZXZlbnQuICovXHJcbiAgICBfb25DaGFuZ2VFdmVudChldmVudDogRXZlbnQpOiB2b2lkO1xyXG4gICAgLyoqIE1ldGhvZCBiZWluZyBjYWxsZWQgd2hlbmV2ZXIgdGhlIHNsaWRlLXRvZ2dsZSBoYXMgYmVlbiBjbGlja2VkLiAqL1xyXG4gICAgX29uSW5wdXRDbGljayhldmVudDogRXZlbnQpOiB2b2lkO1xyXG4gICAgLyoqIEltcGxlbWVudGVkIGFzIHBhcnQgb2YgQ29udHJvbFZhbHVlQWNjZXNzb3IuICovXHJcbiAgICB3cml0ZVZhbHVlKHZhbHVlOiBhbnkpOiB2b2lkO1xyXG4gICAgLyoqIEltcGxlbWVudGVkIGFzIHBhcnQgb2YgQ29udHJvbFZhbHVlQWNjZXNzb3IuICovXHJcbiAgICByZWdpc3Rlck9uQ2hhbmdlKGZuOiBhbnkpOiB2b2lkO1xyXG4gICAgLyoqIEltcGxlbWVudGVkIGFzIHBhcnQgb2YgQ29udHJvbFZhbHVlQWNjZXNzb3IuICovXHJcbiAgICByZWdpc3Rlck9uVG91Y2hlZChmbjogYW55KTogdm9pZDtcclxuICAgIC8qKiBJbXBsZW1lbnRlZCBhcyBhIHBhcnQgb2YgQ29udHJvbFZhbHVlQWNjZXNzb3IuICovXHJcbiAgICBzZXREaXNhYmxlZFN0YXRlKGlzRGlzYWJsZWQ6IGJvb2xlYW4pOiB2b2lkO1xyXG4gICAgLyoqIEZvY3VzZXMgdGhlIHNsaWRlLXRvZ2dsZS4gKi9cclxuICAgIGZvY3VzKG9wdGlvbnM/OiBGb2N1c09wdGlvbnMpOiB2b2lkO1xyXG4gICAgLyoqIFRvZ2dsZXMgdGhlIGNoZWNrZWQgc3RhdGUgb2YgdGhlIHNsaWRlLXRvZ2dsZS4gKi9cclxuICAgIHRvZ2dsZSgpOiB2b2lkO1xyXG4gICAgLyoqXHJcbiAgICAgKiBFbWl0cyBhIGNoYW5nZSBldmVudCBvbiB0aGUgYGNoYW5nZWAgb3V0cHV0LiBBbHNvIG5vdGlmaWVzIHRoZSBGb3JtQ29udHJvbCBhYm91dCB0aGUgY2hhbmdlLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIF9lbWl0Q2hhbmdlRXZlbnQ7XHJcbiAgICAvKiogUmV0cmlldmVzIHRoZSBwZXJjZW50YWdlIG9mIHRodW1iIGZyb20gdGhlIG1vdmVkIGRpc3RhbmNlLiBQZXJjZW50YWdlIGFzIGZyYWN0aW9uIG9mIDEwMC4gKi9cclxuICAgIHByaXZhdGUgX2dldERyYWdQZXJjZW50YWdlO1xyXG4gICAgX29uRHJhZ1N0YXJ0KCk6IHZvaWQ7XHJcbiAgICBfb25EcmFnKGV2ZW50OiBIYW1tZXJJbnB1dCk6IHZvaWQ7XHJcbiAgICBfb25EcmFnRW5kKCk6IHZvaWQ7XHJcbiAgICAvKiogTWV0aG9kIGJlaW5nIGNhbGxlZCB3aGVuZXZlciB0aGUgbGFiZWwgdGV4dCBjaGFuZ2VzLiAqL1xyXG4gICAgX29uTGFiZWxUZXh0Q2hhbmdlKCk6IHZvaWQ7XHJcbn1cclxuZXhwb3J0IHt9O1xyXG4iXX0=